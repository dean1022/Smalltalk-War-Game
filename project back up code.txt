SmallTalk Project War Card Game - CPS 506 TMU 3rd Year
Lasini Kurukulasooriya 501044232 Professor Daniel Franklin
---------------------------------------------------------
Object subclass: #War
	instanceVariableNames: 'deck p1 p2 rArray winDeck'
	classVariableNames: ''
	package: 'CPS506'

LLasini Kurukulasooriya 
501044232
CPS 506 Smalltalk Project
Professor Daniel Fraklin
2023-03-06

I represent a game called War, played between two players that each recieve 26 cards faced down. 
This game is either won by a tie or one player winning all the cards.
Each pile is kept faced down and players take turns to turn over the top card of their pile.
Each turn, they check whose card ranks higher or if war happens.
Whoever wins the turn or war round, they place those cards under their pile in decreasing order.

The ranking for the game is the following in decreasing order:

1-Ace, 13-King, 12-Queen, 11-Jack, 10, 9, 8, 7, 6, 5, 4, 3, 2


Instance Variables
deck:		<Object> Holds the intial deck gives through the Playground
p1:		<Object> Holds the deck of player 1
p2:		<Object> Holds the deck of player 2
rArray:	<Object> The array of cards for each round that the winner will put at the bottom of their deck.
winDeck:	<Object> Holds the winner's deck.

Below are some test cases that can be observed for the decks sent and the results expected; the code below can tested through the Playground:

| tests results |

"
These test cases assume that the TOP of the deck is the FRONT of the array.
That is, the top card is index 1, 2nd from the top is index 2, etc.
If your deal: logic is opposite, simply reverse the array in your method,
and reverse it back before returning.
"
tests := #(
	"One long war until the end. This is technically a tie, but since
	we are returning the pile and not declaring a winner, simply return
	the tied pile (the warchest)"
	#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9
		7 7 7 7 8 8 8 8 6 6 6 6 5 5 5 5 4 4 4 4 3 3 3 3 2 2 2 2)
	"War at the start, then player 1 wins every draw"
	#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9
		8 7 8 7 8 7 8 7 6 5 6 5 6 5 6 5 4 3 4 3 4 3 4 3 2 2 2 2)
	"Same as above, but players are inverted. Good sanity check."
	#(13 1 13 1 13 1 13 1 11 12 11 12 11 12 11 12 9 10 9 10 9 10 9 10 
		7 8 7 8 7 8 7 8 5 6 5 6 5 6 5 6 3 4 3 4 3 4 3 4 2 2 2 2)
	"Medium length game with 4 wars, finishes on a war"
	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9
		10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9)
	"Long game with 11 wars, several of which are multiple rounds"
	#(1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13
		1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13)
	"Test 1 - Starts with lots of back and forth, then 6 wars, some are long wars"
	#(4 4 13 6 12 6 2 10 7 8 6 1 12 3 11 11 11 13 9 5 8 3 10 8 1 
		13 3 1 10 5 3 10 7 2 13 12 4 7 12 6 7 8 9 1 5 4 5 2 9 11 2 9)
	"Test 2 - 19 wars; all are one round wars."
	#(8 7 8 13 2 11 12 3 6 10 5 1 10 3 9 6 1 8 3 7 2 4 7 13 1 11 
		6 1 10 5 11 13 4 2 3 8 9 11 2 5 9 13 10 6 12 12 9 4 5 4 12 7)
	"Test 3 - Player 2 starts to win cards but after the two wars at the beginning, 		player 1 takes over and wins the game."
	#(10 4 8 2 12 5 5 4 1 3 1 12 3 8 5 11 11 2 9 10 8 4 7 4 13 10 13 10 
		6 5 3 12 7 7 12 9 3 13 1 1 13 8 6 9 11 2 2 7 6 11 6 9)
	"Test 4 - One war at the beginning and one war at the end."
	#(4 5 9 11 13 11 12 7 7 13 10 9 4 10 9 11 2 2 6 1 2 13 9 6 6 10 3 5 
		7 13 11 7 8 1 3 8 4 5 12 1 5 4 3 10 3 12 5 8 2 12 8 1)
	"Test 5 - The closest to no war that was achieved was ending it with a tie."
	#(1 1 1 1 8 13 2 12 3 11 4 10 5 9 6 7 8 13 2 12 3 11 4 10 5 9 6 7 
			 8 13 2 12 3 11 4 10 5 9 6 7 8 13 2 12 3 11 4 10 5 9 6 7)
).
results := #(
	#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 
		8 8 8 8 7 7 7 7 6 6 6 6 5 5 5 5 4 4 4 4 3 3 3 3 2 2 2 2)
	#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 
		10 9 10 9 10 9 10 9 12 11 12 11 12 11 12 11 1 13 1 13 1 13 1 13)
	#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 
		10 9 10 9 10 9 10 9 12 11 12 11 12 11 12 11 1 13 1 13 1 13 1 13)
	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 
		12 7 5 11 4 9 3 8 6 7 2 13 10 12 5 11 11 10 8 6 4 6 3 2 2)
	#(1 10 13 8 11 9 8 7 11 8 13 7 13 6 12 6 9 5 8 5 7 4 7 4 11 6 12 
		10 6 3 2 2 12 5 9 3 10 4 9 2 10 3 5 2 1 1 1 13 12 11 4 3)
	"Original Test 1"
	#(1 12 10 3 12 11 1 10 13 7 13 7 10 5 13 6 12 4 10 8 9 6 4 3 3 2 
		1 12 11 8 11 4 9 2 8 7 7 5 11 5 9 4 6 2 6 3 5 2 1 9 13 8)	
	"Original Test 2"
	#(8 7 12 7 1 10 6 6 6 5 12 5 5 4 1 3 13 3 1 13 13 12 10 10 9 8 13 
		8 8 4 11 9 11 9 12 6 10 4 1 11 5 4 2 2 11 3 9 2 7 3 7 2)
	"Original Test 3"
	#(11 9 13 11 8 6 1 7 1 2 13 9 12 6 12 11 7 5 6 3 3 2 13 10 10 9 13 
		9 10 3 8 6 11 8 1 7 12 4 1 5 4 2 12 4 5 3 8 7 10 5 4 2)
	"Original Test 4"
	#(4 2 1 6 8 5 13 9 7 3 10 7 6 3 13 7 1 9 11 8 10 3 13 5 7 2 11 8 9 
		6 1 5 5 4 4 2 12 3 11 2 1 12 12 10 9 5 13 4 12 10 11 8)
	"Original Test 5"
	#(7 6 9 5 10 4 11 3 12 2 13 8 7 6 9 5 10 4 11 3 12 2 13 8 7 6 9 5 
		10 4 11 3 12 2 13 8 7 6 9 5 10 4 11 3 12 2 13 8 1 1 1 1)
).

Transcript clear.
1 to: (results size) do: [ :i |
	| shuffling should_be you_said |
	shuffling := tests at: i.
	should_be := results at: i.
	you_said := War deal: shuffling.

	you_said = should_be 
	ifTrue: [ 
		Transcript show: 'Test '; show: i; show: ': PASSED'; cr.
	]
	ifFalse: [ 
		Transcript show: 'Test '; show: i; show: ': FAILED'; cr.
	]
]


-------------------------------------------

deal: deck

"Creates the object that holds the game. Afterwards, the deck is send to the 
method called setDeck on the instance side to intialize the deck and start the game. 
Since the winner's deck, that is send back here after the game, still has the Aces 
that were turned from 1 to 14 for convienice's sake; before returning the deck to the playground, 
the Aces are returned back to normal."

| obj result |
obj := self new.
obj setDeck: deck.
result := (obj getWinDeck) asArray.
result replaceAll: 14 with: 1.
^result

--------------------------------------------------

addToArray

	"The variable rArray stores the top cards of each player for it to be later checked 
	if it is a war session or if one card ranks higher. Either way, after checking, 
	the cards are removed from the top of the decks and later placed under the deck of 
	the player that won the round in the game."
	
	rArray add: p1 first.
	rArray add: p2 first.
	p1 removeFirst.
	p2 removeFirst.


---------------------------------------------


empty

	"If both players' decks are empty, then the game is a tie. The tie deck is returned."
	((p1 isEmpty) and: [p2 isEmpty]) ifTrue: [ 
		winDeck addAll: rArray.
		^nil ].
	
	"If only player 2's deck is empty, player 1's deck is declared the winner's deck after 
	making sure all cards from the last round or war session is also added to the winner's deck."
	p2 isEmpty ifTrue: [ 
		winDeck:=p1. 
		winDeck addAll: rArray.
		^nil].
	
	"If only player 1's deck is empty, player 2's deck is declared the winner's deck after 
	making sure all cards from the last round or war session is also added to the winner's deck."
	p1 isEmpty ifTrue: [ 
		winDeck:=p2. 
		winDeck addAll: rArray.
		^nil].
^nil

-----------------------------------------------------

getDeck

^deck

--------------------------------------------------------

getP1

^p1

--------------------------------------------------------

getP2

^p2

-----------------------------------------------------------------------------

getWinDeck
^winDeck

-------------------------------------------------------------------

p1Won

	"Adds the cards player 1 won for the round or war session into their deck. The array used for the rounds are emptied after."
	self addToArray.
	p1 addAll: rArray.
	rArray removeAll.

--------------------------------------------------------------

p2Won

	"Adds the cards player 2 won for the round or war session into their deck. The array used for the rounds are emptied after."
	self addToArray.
	p2 addAll: rArray.
	rArray removeAll.

------------------------------------------------------------

setDeck: cards

"This method nitializes the instance variables and send the message to start the game at the end."

"The deck provided for test cases has to reversed since the side this program starts on is opposite."
deck := cards reversed. 
p1 := OrderedCollection new.
p2 := OrderedCollection new. 
rArray := SortedCollection sortBlock: [:a :c | a > c].
winDeck := OrderedCollection new.

"The below code gives each player 26 cards by going through the deck one by one."
deck withIndexDo: [ :item :i | (i rem: 2)=1 ifTrue: [p1 add: item ] ifFalse: [p2 add: item ]].

"The two lines below converts all the 1(Aces) to 14 so it's easier to check rank later."
p1 replaceAll: 1 with: 14.
p2 replaceAll: 1 with: 14.

^self startGame



---------------------------------------------------------

startGame
	"This method is where the game starts after the object from the class side is made."

	"Checks if the players' decks are empty, if so, the winner or tie deck is returned."
	((p1 isEmpty) or: [p2 isEmpty]) ifTrue: [ ^self empty ].
	rArray isNotEmpty ifTrue: [ self addToArray. ].
	((p1 isEmpty) or: [p2 isEmpty]) ifTrue: [ ^self empty ].
	
	"Checks if the top cards of each player is a tie, if so, they will start war."
	p1 first = p2 first ifTrue: [ 
		self addToArray.
		^self startGame].
	
	"Checks if player 1's top card is higher then player 2's top card, if so, 
	player 1 takes the cards and places them under their own deck in decreasing order"
	p1 first > p2 first ifTrue: [ 
		self p1Won. 
		^self startGame].

	"Checks if player 2's top card is higher then player 1's top card, if so, 
	player 2 takes the cards and places them under their own deck in decreasing order"
	p1 first < p2 first ifTrue: [ 
		self p2Won.
		^self startGame].
^nil

-------------------------------------------------------------

